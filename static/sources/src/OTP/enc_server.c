/* Name: Derek Greene
*  OSU Email: greenede@oregonstate.edu
*  Course: CS 374 Operating Systems I
*  Assignment: OTP
*  Due Date: 3/16/2025
*  Description: This program serves as an encyption server in a one-time-pad system. Plainext and key data are recieved from
*               a client (enc_client.c) and encrypted using a one-time pad generated by keygen (keygen.c).  
*
*  References:
*  The Linux Programming Interface: a Linux and UNIX system programming handbook. Kerrisk, M. (2010)
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define BUFFER_SIZE 1024 // buffer size for sending/recieving data


/*
* Function to encrypt plaintext using one-time pad key
* Parameters: char* plaintext, int textLength, char* key, int keyLength
* Returns: void
*/
void encrypt(char* plaintext, int textLength, char* key, int keyLength) {
  int charVal, keyVal, encryptedChar;
  
  for (int i = 0; i < textLength; i++) {
    if (plaintext[i] == '\n') { // ignore newline chars
      continue;
    }
    if (plaintext[i] == ' ') {
      charVal = 26;
    } else {
      charVal = plaintext[i] - 'A'; // convert char to int
    }
    if (key[i] == ' ') {
      keyVal = 26;
    } else {
      keyVal = key[i] - 'A';
    }
    
    encryptedChar = (charVal + keyVal) % 27; // encrypt char
    if (encryptedChar == 26) {
      plaintext[i] = ' '; 
    } else {
      plaintext[i] = encryptedChar + 'A';
    }
  }
}


/*
* Function to print error messages
* Parameters: const char *msg
* Returns: void
*/
void error(const char *msg) {
  perror(msg);
  exit(1);
} 


/* 
* Function to create address struct for server
* Parameters: struct sockaddr_in* address, int portNumber
* Returns: void
*/
void setupAddressStruct(struct sockaddr_in* address, int portNumber) {
  memset((char*) address, '\0', sizeof(*address)); // clear address struct
  address->sin_family = AF_INET; // IPv4
  address->sin_port = htons(portNumber); // port num
  address->sin_addr.s_addr = INADDR_ANY; // accept conns from any address
}


/*
* Main Function
* Parameters: int argc, char *argv[]
* Returns: int
*/
int main(int argc, char *argv[]) {
  int connectionSocket, listenSocket, plaintextSize, encryptedSize, bytesReceived, bytesSent, 
  totalReceived, totalSent ,networkSize, remainingBytes, messageSize, keySize; 
  struct sockaddr_in serverAddress, clientAddress;
  socklen_t sizeOfClientInfo = sizeof(clientAddress);
  char *plaintext, *key, *ack, *keyAck, *handshake = "enc_server";
  
  // check for correct argument count
  if (argc < 2) { 
    fprintf(stderr, "USAGE: %s port\n", argv[0]); 
    exit(1);
  } 

  // create socket
  listenSocket = socket(AF_INET, SOCK_STREAM, 0);
  if (listenSocket < 0) {
    error("ERROR opening socket");
  }
  
  setupAddressStruct(&serverAddress, atoi(argv[1]));
  if (bind(listenSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {
    error("ERROR on binding");
  }
  listen(listenSocket, 5); 

  // loop to accept connections
  while(1) {
    connectionSocket = accept(listenSocket, (struct sockaddr *)&clientAddress, &sizeOfClientInfo); 
    
    if (connectionSocket < 0) {
      error("ERROR on accept");
    }
    
    // fork child to handle multiple connections
    pid_t spawnPid = fork();
    switch(spawnPid) {
      case -1: 
        perror("fork()\n");
        exit(1);
        break;
      
      case 0: // child process
        printf("SERVER: Connected to client running at host %d port %d\n", ntohs(clientAddress.sin_addr.s_addr), ntohs(clientAddress.sin_port));
        
        // send handshake to client "enc_server"
        if (send(connectionSocket, handshake, strlen(handshake), 0) < 0) {
          error("ERROR sending handshake");
        }
        if (recv(connectionSocket, &plaintextSize, sizeof(plaintextSize), 0) < 0) {
          error("ERROR reading plaintext size from socket");
        }

        // recieve plaintext size and allocate memory
        plaintextSize = ntohl(plaintextSize);
        plaintext = malloc(plaintextSize + 1);

        if (plaintext == NULL) {
          error("ERROR allocating memory for plaintext");
        }
        memset(plaintext, '\0', plaintextSize + 1);
        totalReceived = 0;
        
        // recieve plaintext data 
        while (totalReceived < plaintextSize) {
          bytesReceived = recv(connectionSocket, plaintext + totalReceived, plaintextSize - totalReceived, 0);

          if (bytesReceived < 0) {
            error("ERROR reading plaintext from socket");
          }
          if (bytesReceived == 0) {
            break;
          }
          totalReceived += bytesReceived;
        }

        // remove newline char from plaintext
        if (plaintext[plaintextSize - 1] == '\n') {
          plaintext[plaintextSize - 1] = '\0';
          plaintextSize--; 
        }
        
        // send "ack" for plaintext to client
        ack = "I am the server, and I got your plaintext";
        if (send(connectionSocket, ack, strlen(ack), 0) < 0) {
          error("ERROR sending plaintext acknowledgment");
        }
        
        // recieve key size and allocate memory
        if (recv(connectionSocket, &keySize, sizeof(keySize), 0) < 0) {
          error("ERROR reading key size from socket");
        }

        keySize = ntohl(keySize);
        key = malloc(keySize + 1);

        if (key == NULL) {
          error("ERROR allocating memory for key");
        }
        memset(key, '\0', keySize + 1);
        totalReceived = 0;

        // recieve key data
        while (totalReceived < keySize) {
          bytesReceived = recv(connectionSocket, key + totalReceived, keySize - totalReceived, 0);

          if (bytesReceived < 0) {
            error("ERROR reading key from socket");
          }
          if (bytesReceived == 0) {
            break;
          }
          totalReceived += bytesReceived;
        }

        // send "ack" for key to client
        keyAck = "I am the server, and I got your key";
        if (send(connectionSocket, keyAck, strlen(keyAck), 0) < 0) {
          error("ERROR sending key acknowledgment");
        }

        printf("SERVER: Plaintext received (%d bytes)\n", plaintextSize);
        printf("SERVER: Key received (%d bytes)\n", keySize);
        encrypt(plaintext, plaintextSize, key, keySize); // encrypt plaintext
        plaintext[plaintextSize] = '\n'; // add newline char to plaintext
        encryptedSize = plaintextSize + 1;
        networkSize = htonl(encryptedSize); 

        // send encrypted data size
        if (send(connectionSocket, &networkSize, sizeof(networkSize), 0) < 0) {
          error("ERROR sending encrypted size");
        }
        
        // send encrypted data in chunks (1024 bytes)
        totalSent = 0;
        while (totalSent < encryptedSize) {
          remainingBytes = encryptedSize - totalSent;
          if (remainingBytes > BUFFER_SIZE) {
            messageSize = BUFFER_SIZE;
          } else {
            messageSize = remainingBytes;
          }
          bytesSent = send(connectionSocket, plaintext + totalSent, messageSize, 0);
          
          if (bytesSent < 0) {
            error("ERROR writing encrypted data to socket");
          }
          totalSent += bytesSent;
        }
        
        printf("SERVER: Encrypted data sent (%d bytes)\n", totalSent);
        // free memory & close connection
        free(plaintext);
        free(key);
        close(connectionSocket);
        exit(0);
        break;
      
      default: // parent process
        close(connectionSocket);
        break;
    }
  }
  close(listenSocket);
  return 0;
}