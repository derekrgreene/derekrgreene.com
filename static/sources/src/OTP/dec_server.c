/* Name: Derek Greene
*  OSU Email: greenede@oregonstate.edu
*  Course: CS 374 Operating Systems I
*  Assignment: OTP
*  Due Date: 3/16/2025
*  Description: This program serves as a decryption server in a one-time-pad system. Ciphertext and key data are recieved from
*               a client (dec_client.c) and decrypted using a one-time pad generated by keygen (keygen.c).  
*
*  References:
*  The Linux Programming Interface: a Linux and UNIX system programming handbook. Kerrisk, M. (2010)
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define BUFFER_SIZE 1024 // buffer size for sending/recieving data


/*
* Function to decrypt ciphertext using one-time pad key
* Parameters: char* ciphertext, int textLength, char* key, int keyLength
* Returns: void
*/
void decrypt(char* ciphertext, int textLength, char* key, int keyLength) {
  int charVal, keyVal, decryptedChar;
  
  for (int i = 0; i < textLength; i++) {
    if (ciphertext[i] == '\n') { // ignore newline chars
      continue;
    }
    if (ciphertext[i] == ' ') {
      charVal = 26;
    } else {
      charVal = ciphertext[i] - 'A'; // convert char to int
    }
    if (key[i] == ' ') {
      keyVal = 26;
    } else {
      keyVal = key[i] - 'A';
    }
    
    decryptedChar = (charVal - keyVal + 27) % 27; // decrypt char
    if (decryptedChar == 26) {
      ciphertext[i] = ' ';
    } else {
      ciphertext[i] = decryptedChar + 'A';
    }
  }
}


/*
* Function to print error messages
* Parameters: const char *msg
* Returns: void
*/
void error(const char *msg) {
  perror(msg);
  exit(1);
} 


/* 
* Function to create address struct for server
* Parameters: struct sockaddr_in* address, int portNumber
* Returns: void
*/
void setupAddressStruct(struct sockaddr_in* address, int portNumber) {
  memset((char*) address, '\0', sizeof(*address)); // clear address struct
  address->sin_family = AF_INET; // IPv4
  address->sin_port = htons(portNumber); // port num
  address->sin_addr.s_addr = INADDR_ANY; // accept conns from any address
}


/*
* Main Function
* Parameters: int argc, char *argv[]
* Returns: int
*/
int main(int argc, char *argv[]) {
  int connectionSocket, listenSocket, ciphertextSize, decryptedSize, bytesReceived, bytesSent,
  totalReceived, totalSent, remainingBytes, messageSize, networkSize, keySize; 
  struct sockaddr_in serverAddress, clientAddress;
  socklen_t sizeOfClientInfo = sizeof(clientAddress);
  char *ciphertext, *ack, *keyAck, *key, *handshake = "dec_server";
  
  // check for correct argument count
  if (argc < 2) { 
    fprintf(stderr, "USAGE: %s port\n", argv[0]); 
    exit(1);
  } 

  // create socket
  listenSocket = socket(AF_INET, SOCK_STREAM, 0);
  if (listenSocket < 0) {
    error("ERROR opening socket");
  }
  
  setupAddressStruct(&serverAddress, atoi(argv[1]));
  if (bind(listenSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {
    error("ERROR on binding");
  }
  listen(listenSocket, 5); 

  // loop to accept connections
  while(1) {
    connectionSocket = accept(listenSocket, (struct sockaddr *)&clientAddress, &sizeOfClientInfo); 
    
    if (connectionSocket < 0) {
      error("ERROR on accept");
    }

    // fork child to handle multiple connections
    pid_t spawnPid = fork();
    switch(spawnPid) {
      case -1: 
        perror("fork()\n");
        exit(1);
        break;
      
      case 0: // child process
        printf("SERVER: Connected to client running at host %d port %d\n", ntohs(clientAddress.sin_addr.s_addr), ntohs(clientAddress.sin_port));
        
        // send handshake to client "dec_server"
        if (send(connectionSocket, handshake, strlen(handshake), 0) < 0) {
          error("ERROR sending handshake");
        }
        if (recv(connectionSocket, &ciphertextSize, sizeof(ciphertextSize), 0) < 0) {
          error("ERROR reading ciphertext size from socket");
        }

        // recieve ciphertext size and allocate memory
        ciphertextSize = ntohl(ciphertextSize);
        ciphertext = malloc(ciphertextSize);

        if (ciphertext == NULL) {
          error("ERROR allocating memory for ciphertext");
        }
        memset(ciphertext, '\0', ciphertextSize + 1);
        totalReceived = 0;
        
        // recieve ciphertext data 
        while (totalReceived < ciphertextSize) {
          bytesReceived = recv(connectionSocket, ciphertext + totalReceived, ciphertextSize - totalReceived, 0);

          if (bytesReceived < 0) {
            error("ERROR reading ciphertext from socket");
          }
          if (bytesReceived == 0) {
            break;
          }
          totalReceived += bytesReceived;
        }

        // remove newline char from ciphertext
        if (ciphertext[ciphertextSize - 1] == '\n') {
          ciphertext[ciphertextSize - 1] = '\0';
          ciphertextSize--; 
        }
        
        // send "ack" for ciphertext to client
        ack = "I am the server, and I got your ciphertext";
        if (send(connectionSocket, ack, strlen(ack), 0) < 0) {
          error("ERROR sending ciphertext acknowledgment");
        }
        
        // recieve key size and allocate memory
        if (recv(connectionSocket, &keySize, sizeof(keySize), 0) < 0) {
          error("ERROR reading key size from socket");
        }

        keySize = ntohl(keySize);
        key = malloc(keySize + 1);

        if (key == NULL) {
          error("ERROR allocating memory for key");
        }
        memset(key, '\0', keySize + 1);
        totalReceived = 0;

        // recieve key data
        while (totalReceived < keySize) {
          bytesReceived = recv(connectionSocket, key + totalReceived, keySize - totalReceived, 0);

          if (bytesReceived < 0) {
            error("ERROR reading key from socket");
          }
          if (bytesReceived == 0) {
            break;
          }
          totalReceived += bytesReceived;
        }

        // send "ack" for key to client
        keyAck = "I am the server, and I got your key";
        if (send(connectionSocket, keyAck, strlen(keyAck), 0) < 0) {
          error("ERROR sending key acknowledgment");
        }

        printf("SERVER: ciphertext received (%d bytes)\n", ciphertextSize);
        printf("SERVER: Key received (%d bytes)\n", keySize);
        decrypt(ciphertext, ciphertextSize, key, keySize); // decrypt ciphertext
        ciphertext[ciphertextSize] = '\n'; // add newline char to decrypted text
        decryptedSize = ciphertextSize + 1;
        networkSize = htonl(decryptedSize); 

        // send decrypted data size
        if (send(connectionSocket, &networkSize, sizeof(networkSize), 0) < 0) {
          error("ERROR sending decrypted size");
        }
        
        // send decrypted data in chunks (1024 bytes)
        totalSent = 0;
        while (totalSent < decryptedSize) {
          remainingBytes = decryptedSize - totalSent;
          if (remainingBytes > BUFFER_SIZE) {
            messageSize = BUFFER_SIZE;
          } else {
            messageSize = remainingBytes;
          }
          bytesSent = send(connectionSocket, ciphertext + totalSent, messageSize, 0);
          if (bytesSent < 0) {
            error("CLIENT: ERROR writing key to socket");
          }
          totalSent += bytesSent;
        }
        
        printf("SERVER: decrypted data sent (%d bytes)\n", totalSent);
        // free memory & close connection
        free(ciphertext);
        free(key);
        close(connectionSocket);
        exit(0);
        break;
      
      default: // parent process
        close(connectionSocket);
        break;
    }
  }
  close(listenSocket);
  return 0;
}