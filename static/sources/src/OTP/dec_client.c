/* Name: Derek Greene
*  OSU Email: greenede@oregonstate.edu
*  Course: CS 374 Operating Systems I
*  Assignment: OTP
*  Due Date: 3/16/2025
*  Description: This program serves as an client in a one-time-pad system. Ciphertext and key data are 
*               sent from this client to a server (dec_server.c) for decryption using a one-time pad generated by keygen (keygen.c).  
*
*  References:
*  The Linux Programming Interface: a Linux and UNIX system programming handbook. Kerrisk, M. (2010)
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netdb.h>

#define BUFFER_SIZE 1024 // buffer size for sending/recieving data


/*
* Function to print error messages
* Parameters: const char *msg
* Returns: void
*/
void error(const char *msg) { 
  perror(msg); 
  exit(0); 
} 


/* 
* Function to create address struct for server
* Parameters: struct sockaddr_in* address, int portNumber
* Returns: void
*/
void setupAddressStruct(struct sockaddr_in* address, int portNumber, char* hostname) {
  memset((char*) address, '\0', sizeof(*address));  // clear address struct
  address->sin_family = AF_INET; // IPv4
  address->sin_port = htons(portNumber); // port num
  struct hostent* hostInfo = gethostbyname(hostname); // get server host info

  if (hostInfo == NULL) { 
    fprintf(stderr, "CLIENT: ERROR, no such host\n"); 
    exit(0); 
  }
  memcpy((char*) &address->sin_addr.s_addr, hostInfo->h_addr_list[0],hostInfo->h_length);
}


/*
* Function to check if input file contains valid characters
* Parameters: char* fileName
* Returns: int
*/
int validChars(char* fileName) {
  FILE* file = fopen(fileName, "r");
  char c;
  while ((c = fgetc(file)) != EOF) {
    if ((c < 'A' || c > 'Z') && c != ' ' && c != '\n') {
      fclose(file);
      return 0; // invalid char found
    }
  }
  fclose(file);
  return 1;  // all valid chars
}


/*
* Function to read file data into buffer
* Parameters: char* fileName, long *fileSize
* Returns: char*
*/
char* processFile(char* fileName, long *fileSize) {
  struct stat fileStat;
  FILE* file = fopen(fileName, "r");

  if (file == NULL) {
    error("CLIENT: ERROR opening file");
  }

  stat(fileName, &fileStat);
  *fileSize = fileStat.st_size; // get file size

  // check for valid chars
  if (!validChars(fileName)) {
    fprintf(stderr, "error: input contains bad characters");
    exit(1);
  }

  // read file data into buffer & allocate memory
  char* buffer = malloc(*fileSize + 1);
  fread(buffer, 1, *fileSize, file);
  buffer[*fileSize] = '\0'; // add null terminator
  fclose(file);
  return buffer;
}


/*
* Main Function
* Parameters: int argc, char *argv[]
* Returns: int
*/
int main(int argc, char *argv[]) {
  int socketFD, windowSize, totalSent, totalReceived, bytesSent, 
  bytesReceived, remainingBytes, messageSize, decryptedSize;
  struct sockaddr_in serverAddress;
  char buffer[BUFFER_SIZE];
  char *ciphertext, *key, *decryptedData;
  long ciphertextSize, keySize;
  
  // check for correct argument count
  if (argc < 4) { 
    fprintf(stderr, "USAGE: %s ciphertext key port\n", argv[0]); 
    exit(0); 
  } 
  
  // read ciphertext and key data into buffers
  ciphertext = processFile(argv[1], &ciphertextSize);
  key = processFile(argv[2], &keySize);

  // check if key is too short
  if (keySize < ciphertextSize) {
    fprintf(stderr, "CLIENT: ERROR key '%s' is too short\n", argv[2]);
    exit(1);
  }

  // create socket
  socketFD = socket(AF_INET, SOCK_STREAM, 0); 
  if (socketFD < 0) {
    error("CLIENT: ERROR opening socket");
  }
  setupAddressStruct(&serverAddress, atoi(argv[3]), "localhost");

  // connect to server
  if (connect(socketFD, (struct sockaddr*)&serverAddress, sizeof(serverAddress)) < 0) {
    error("CLIENT: ERROR connecting");
  }

  memset(buffer, '\0', BUFFER_SIZE); // clear buffer
  recv(socketFD, buffer, BUFFER_SIZE - 1, 0); // recieve handshake from server

  // check if server is dec_server
  if (strcmp(buffer, "dec_server") != 0) {
    fprintf(stderr, "CLIENT: ERROR Invalid Server on port %s", argv[3]);
    close(socketFD);
    exit(2);
  }

  // send ciphertext size to server
  windowSize = htonl((int)ciphertextSize);
  if (send(socketFD, &windowSize, sizeof(windowSize), 0) < 0) {
    error("CLIENT: ERROR sending ciphertext size");
  }
  
  // send ciphertext data to server in chunks (1024 bytes) 
  totalSent = 0;
  while (totalSent < ciphertextSize) {
    remainingBytes = ciphertextSize - totalSent;
    if (remainingBytes > BUFFER_SIZE) {
        messageSize = BUFFER_SIZE;
    } else {
        messageSize = remainingBytes;
    }
    bytesSent = send(socketFD, ciphertext + totalSent, messageSize, 0);
    totalSent += bytesSent;
  }

  memset(buffer, '\0', BUFFER_SIZE);
  if (recv(socketFD, buffer, BUFFER_SIZE - 1, 0) < 0) { // recieve "ack" from server
    error("CLIENT: ERROR reading ack from socket");
  }
  windowSize = htonl((int)keySize);

  // send key size to server
  if (send(socketFD, &windowSize, sizeof(windowSize), 0) < 0) { 
    error("CLIENT: ERROR sending key size");
  }
  
  // send key data to server in chunks (1024 bytes)
  totalSent = 0;
  while (totalSent < keySize) {
    remainingBytes = keySize - totalSent;
    if (remainingBytes > BUFFER_SIZE) {
      messageSize = BUFFER_SIZE;
    } else {
      messageSize = remainingBytes;
    }
    bytesSent = send(socketFD, key + totalSent, messageSize, 0);
    if (bytesSent < 0) {
      error("CLIENT: ERROR writing key to socket");
    }
    totalSent += bytesSent;
  }

  memset(buffer, '\0', BUFFER_SIZE);
  if (recv(socketFD, buffer, BUFFER_SIZE - 1, 0) < 0) { // recieve "ack" from server
    error("CLIENT: ERROR reading ack from socket");
  }

  // recieve decrypted data size from server
  if (recv(socketFD, &decryptedSize, sizeof(decryptedSize), 0) < 0) {
    error("CLIENT: ERROR reading decrypted size from socket");
  }
  decryptedSize = ntohl(decryptedSize);
  decryptedData = malloc(decryptedSize + 1); // allocate memory for decrypted data

  if (decryptedData == NULL) {
    error("CLIENT: ERROR allocating memory for decrypted data");
  }
  memset(decryptedData, '\0', decryptedSize + 1);
  
  // recieve decrypted data from server in chunks (1024 bytes)
  totalReceived = 0;
  while (totalReceived < decryptedSize) { 
    bytesReceived = recv(socketFD, decryptedData + totalReceived, decryptedSize - totalReceived, 0);
    
    if (bytesReceived < 0) {
      error("CLIENT: ERROR reading decrypted data from socket");
    }
    if (bytesReceived == 0) {
      break; 
    }
    totalReceived += bytesReceived;
  }
  
  printf("%s", decryptedData); // print decrypted data to stdout
  // free memory & close connection
  free(ciphertext);
  free(key);
  free(decryptedData);
  close(socketFD);
  return 0;
}